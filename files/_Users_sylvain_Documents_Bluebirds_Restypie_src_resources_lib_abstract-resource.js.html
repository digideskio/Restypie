<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>/Users/sylvain/Documents/Bluebirds/Restypie/src/resources/lib/abstract-resource.js - NodeToolkit</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">NodeToolkit</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 0.1.2
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Restypie.API.html">Restypie.API</a></li>
                                <li><a href="../classes/Restypie.BasicRoutes.html">Restypie.BasicRoutes</a></li>
                                <li><a href="../classes/Restypie.BasicRoutes.DeleteSingleRoute.html">Restypie.BasicRoutes.DeleteSingleRoute</a></li>
                                <li><a href="../classes/Restypie.BasicRoutes.GetManyRoute.html">Restypie.BasicRoutes.GetManyRoute</a></li>
                                <li><a href="../classes/Restypie.BasicRoutes.GetSingleRoute.html">Restypie.BasicRoutes.GetSingleRoute</a></li>
                                <li><a href="../classes/Restypie.BasicRoutes.OptionsRoute.html">Restypie.BasicRoutes.OptionsRoute</a></li>
                                <li><a href="../classes/Restypie.BasicRoutes.PatchSingleRoute.html">Restypie.BasicRoutes.PatchSingleRoute</a></li>
                                <li><a href="../classes/Restypie.BasicRoutes.PostRoute.html">Restypie.BasicRoutes.PostRoute</a></li>
                                <li><a href="../classes/Restypie.BasicRoutes.PutSingleRoute.html">Restypie.BasicRoutes.PutSingleRoute</a></li>
                                <li><a href="../classes/Restypie.Bundle.html">Restypie.Bundle</a></li>
                                <li><a href="../classes/Restypie.Codes.html">Restypie.Codes</a></li>
                                <li><a href="../classes/Restypie.Fields.html">Restypie.Fields</a></li>
                                <li><a href="../classes/Restypie.Fields.AbstractField.html">Restypie.Fields.AbstractField</a></li>
                                <li><a href="../classes/Restypie.Fields.AbstractNumberField.html">Restypie.Fields.AbstractNumberField</a></li>
                                <li><a href="../classes/Restypie.Fields.AbstractRelationField.html">Restypie.Fields.AbstractRelationField</a></li>
                                <li><a href="../classes/Restypie.Fields.AnyField.html">Restypie.Fields.AnyField</a></li>
                                <li><a href="../classes/Restypie.Fields.BooleanField.html">Restypie.Fields.BooleanField</a></li>
                                <li><a href="../classes/Restypie.Fields.DateField.html">Restypie.Fields.DateField</a></li>
                                <li><a href="../classes/Restypie.Fields.FileField.html">Restypie.Fields.FileField</a></li>
                                <li><a href="../classes/Restypie.Fields.FloatField.html">Restypie.Fields.FloatField</a></li>
                                <li><a href="../classes/Restypie.Fields.IntegerField.html">Restypie.Fields.IntegerField</a></li>
                                <li><a href="../classes/Restypie.Fields.StringField.html">Restypie.Fields.StringField</a></li>
                                <li><a href="../classes/Restypie.Fields.ToManyField.html">Restypie.Fields.ToManyField</a></li>
                                <li><a href="../classes/Restypie.Fields.ToOneField.html">Restypie.Fields.ToOneField</a></li>
                                <li><a href="../classes/Restypie.Methods.html">Restypie.Methods</a></li>
                                <li><a href="../classes/Restypie.Operators.html">Restypie.Operators</a></li>
                                <li><a href="../classes/Restypie.Operators.AbstractListOperator.html">Restypie.Operators.AbstractListOperator</a></li>
                                <li><a href="../classes/Restypie.Operators.AbstractOperator.html">Restypie.Operators.AbstractOperator</a></li>
                                <li><a href="../classes/Restypie.Operators.Eq.html">Restypie.Operators.Eq</a></li>
                                <li><a href="../classes/Restypie.Operators.Gt.html">Restypie.Operators.Gt</a></li>
                                <li><a href="../classes/Restypie.Operators.Gte.html">Restypie.Operators.Gte</a></li>
                                <li><a href="../classes/Restypie.Operators.In.html">Restypie.Operators.In</a></li>
                                <li><a href="../classes/Restypie.Operators.Lt.html">Restypie.Operators.Lt</a></li>
                                <li><a href="../classes/Restypie.Operators.Lte.html">Restypie.Operators.Lte</a></li>
                                <li><a href="../classes/Restypie.Operators.Ne.html">Restypie.Operators.Ne</a></li>
                                <li><a href="../classes/Restypie.Operators.Nin.html">Restypie.Operators.Nin</a></li>
                                <li><a href="../classes/Restypie.Resources.html">Restypie.Resources</a></li>
                                <li><a href="../classes/Restypie.Resources.AbstractResource.html">Restypie.Resources.AbstractResource</a></li>
                                <li><a href="../classes/Restypie.Resources.FixturesResource.html">Restypie.Resources.FixturesResource</a></li>
                                <li><a href="../classes/Restypie.Resources.ProxyResource.html">Restypie.Resources.ProxyResource</a></li>
                                <li><a href="../classes/Restypie.Resources.SequelizeResource.html">Restypie.Resources.SequelizeResource</a></li>
                                <li><a href="../classes/Restypie.RestErrors.html">Restypie.RestErrors</a></li>
                                <li><a href="../classes/Restypie.RestErrors.AbstractRestError.html">Restypie.RestErrors.AbstractRestError</a></li>
                                <li><a href="../classes/Restypie.RestErrors.BadRequest.html">Restypie.RestErrors.BadRequest</a></li>
                                <li><a href="../classes/Restypie.RestErrors.Forbidden.html">Restypie.RestErrors.Forbidden</a></li>
                                <li><a href="../classes/Restypie.RestErrors.InternalServerError.html">Restypie.RestErrors.InternalServerError</a></li>
                                <li><a href="../classes/Restypie.RestErrors.NotAcceptable.html">Restypie.RestErrors.NotAcceptable</a></li>
                                <li><a href="../classes/Restypie.RestErrors.NotFound.html">Restypie.RestErrors.NotFound</a></li>
                                <li><a href="../classes/Restypie.RestErrors.NotImplemented.html">Restypie.RestErrors.NotImplemented</a></li>
                                <li><a href="../classes/Restypie.RestErrors.Unauthorized.html">Restypie.RestErrors.Unauthorized</a></li>
                                <li><a href="../classes/Restypie.RestErrors.UnsupportedMediaType.html">Restypie.RestErrors.UnsupportedMediaType</a></li>
                                <li><a href="../classes/Restypie.Route.html">Restypie.Route</a></li>
                                <li><a href="../classes/Restypie.RoutesSorter.html">Restypie.RoutesSorter</a></li>
                                <li><a href="../classes/Restypie.Serializers.html">Restypie.Serializers</a></li>
                                <li><a href="../classes/Restypie.Serializers.AbstractSerializer.html">Restypie.Serializers.AbstractSerializer</a></li>
                                <li><a href="../classes/Restypie.Serializers.JSONSerializer.html">Restypie.Serializers.JSONSerializer</a></li>
                                <li><a href="../classes/Restypie.TemplateErrors.html">Restypie.TemplateErrors</a></li>
                                <li><a href="../classes/Restypie.Url.html">Restypie.Url</a></li>
                                <li><a href="../classes/Restypie.Utils.html">Restypie.Utils</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /Users/sylvain/Documents/Bluebirds/Restypie/src/resources/lib/abstract-resource.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/***********************************************************************************************************************
 * Dependencies
 **********************************************************************************************************************/
let _ = require(&#x27;lodash&#x27;);
let Negotiator = require(&#x27;negotiator&#x27;);
let Busboy = require(&#x27;busboy&#x27;);
let typeIs = require(&#x27;type-is&#x27;);
let formDataToObject = require(&#x27;form-data-to-object&#x27;);
let https = require(&#x27;https&#x27;);
let request = require(&#x27;request&#x27;);

let Restypie = require(&#x27;../../&#x27;);
let Utils = Restypie.Utils;

const RESERVED_KEYWORDS = [&#x27;limit&#x27;, &#x27;offset&#x27;, &#x27;sort&#x27;, &#x27;select&#x27;, &#x27;format&#x27;, &#x27;populate&#x27;];

const DEFAULTS = {
  DEFAULT_LIMIT: 20,
  MAX_LIMIT: 100,
  SERIALIZERS: [Restypie.Serializers.JSONSerializer]
};

/***********************************************************************************************************************
 * @namespace Restypie.Resources
 * @class AbstractResource
 * @extends AbstractCoreResource
 * @constructor
 * @abstract
 **********************************************************************************************************************/
module.exports = class AbstractResource extends Restypie.Resources.AbstractCoreResource {

  /**
   * @property path
   * @type String
   * @default null
   */
  get path() { return null; }

  /**
   * @property schema
   * @type Object
   * @default {}
   */
  get schema() { return {}; }

  /**
   * @property routes
   * @type Restypie.Route[]
   * @default []
   */
  get routes() { return []; }

  /**
   * @property serializers
   * @type Restypie.Serializers.AbstractSerializer[]
   * @default [Restypie.Serializers.JSONSerializer]
   */
  get serializers() { return DEFAULTS.SERIALIZERS; }

  /**
   * @property defaultLimit
   * @type Number
   * @default 20
   */
  get defaultLimit() { return DEFAULTS.DEFAULT_LIMIT; }

  /**
   * @property maxLimit
   * @type Number
   * @default 100
   */
  get maxLimit() { return DEFAULTS.MAX_LIMIT; }


  /**
   * Shortcut to get all &#x60;isReadable&#x60; fields.
   *
   * @attribute readableFields
   * @type Restypie.Fields.AbstractField[]
   */
  get readableFields() { return this.fields.filter(function (field) { return field.isReadable; }); }

  /**
   * Shortcut to get all &#x60;isWritable&#x60; fields.
   *
   * @attribute writableFields
   * @type Restypie.Fields.AbstractField[]
   */
  get writableFields() { return this.fields.filter(function (field) { return field.isWritable; }); }

  /**
   * Shortcut to get all &#x60;isPopulable&#x60; fields.
   *
   * @attribute populableFields
   * @type Restypie.Fields.AbstractField[]
   */
  get populableFields() { return this.fields.filter(function (field) { return field.isPopulable; }); }
  
  get requiredFields() { return this.fields.filter(function (field) { return field.isRequired; }); }

  /**
   * Shortcut to get all file fields (instances of Restypie.Fields.FileField or its subclasses).
   *
   * @attribute fileFields
   * @type Restypie.Fields.FileField[]
   */
  get fileFields() {
    return this.fields.filter(function (field) { return field instanceof Restypie.Fields.FileField; });
  }

  /**
   * List of supported mime types from &#x27;serializers&#x27;.
   *
   * @attribute supportedFormatMimeTypes
   * @type String[]
   */
  get supportedFormatMimeTypes() { return this.serializers.map(function (serializer) { return serializer.mimeType; }); }

  /**
   * List of supported mime type aliases from &#x27;serializers&#x27;.
   *
   * @attribute supportedFormatAliases
   * @type String[]
   */
  get supportedFormatAliases() {
    return this.serializers.reduce(function (acc, serializer) { return acc.concat(serializer.aliases); }, []);
  }

  /**
   * List of supported of both mime types and aliases from &#x27;serializers&#x27;.
   *
   * @attribute supportedFormatMimeTypesAndAliases
   * @type String[]
   */
  get supportedFormatMimeTypesAndAliases() {
    return this.supportedFormatAliases.concat(this.supportedFormatMimeTypes);
  }

  /**
   * Defines whether or not the resource supports uniqueness constraints.
   *
   * @attribute supportsUniqueConstraints
   * @type Boolean
   */
  get supportsUniqueConstraints() { return false; }
  
  
  get supportsUpserts() { return false; }
  
  get upsertPaths() { return []; }

  /**
   * Fields to be selected by default. By default select all readable fields.
   *
   * @attribute defaultSelect
   * @return {Array}
   */
  get defaultSelect() {
    return this.readableFields
      .filter(function (field) { return !field.isRelation; })
      .map(function (field) { return field.key; });
  }

  /**
   * Default sorting : none.
   *
   * @attribute defaultSort
   * @return {Array}
   */
  get defaultSort() { return []; }



  /**
   * @constructor
   */
  constructor(api) {
    super();
    Utils.forceAbstract(this, AbstractResource);
    
    if (!Array.isArray(this.routes)) throw new TypeError(&#x27;Property &#x60;routes&#x60; should be an array&#x27;);
    
    // Create the routes
    this._createRoutes();

    // Keep a reference to the api, do not allow to modify it
    Object.defineProperty(this, &#x27;api&#x27;, { get() { return api; } });

    // Validate properties
    if (!_.isString(this.path)) throw new TypeError(&#x27;Property &#x60;path&#x60; should be a string&#x27;);
    if (!Utils.isValidNumber(this.defaultLimit)) throw new TypeError(&#x27;Property &#x60;defaultLimit&#x60; should be a number&#x27;);
    if (!Utils.isValidNumber(this.maxLimit)) throw new TypeError(&#x27;Property &#x60;maxLimit&#x60; should be a number&#x27;);
    
  }


  beforeValidate(bundle) {
    return bundle.next();
  }

  afterValidate(bundle) {
    return bundle.next();
  }

  beforeHydrate(bundle) {
    return bundle.next();
  }

  afterHydrate(bundle) {
    return bundle.next();
  }

  beforeDehydrate(bundle) {
    return bundle.next();
  }

  afterDehydrate(bundle) {
    return bundle.next();
  }

  beforeParseFilters() {}

  afterParseFilters() {}

  /**
   * Retrieves the &#x60;key&#x60; corresponding to &#x60;path&#x60; from &#x60;fields&#x60;, if any is found.
   *
   * @method fieldPathToKey
   * @param {String} path
   * @return {String|undefined}
   */
  fieldPathToKey(path) {
    let field = this.fields.find(function (item) { return item.path === path; });
    return field &amp;&amp; field.key;
  }

  /**
   * Computes and returns the full url for this resource on its host.
   *
   * @method getFullUrl
   * @return {String}
   */
  getFullUrl() {
    let api = this.api;
    let app = api.app;
    let port = app.get(&#x27;port&#x27;);
    let protocol = app instanceof https.Server ? &#x27;https&#x27; : &#x27;http&#x27;;
    let basePath = Restypie.Url.join(protocol + &#x27;://127.0.0.1:&#x27; + port, api.path);
    return Restypie.Url.join(basePath, this.path);
  }

  /**
   *
   * @method countObjects
   * @return {Promise}
   */
  countObjects() {
    return Promise.reject(new Restypie.RestErrors.NotImplemented());
  }

  /**
   *
   * @method createObject
   * @return {Promise}
   */
  createObject() {
    return Promise.reject(new Restypie.RestErrors.NotImplemented());
  }

  /**
   *
   * @method createObjects
   * @return {Promise}
   */
  createObjects() {
    return Promise.reject(new Restypie.RestErrors.NotImplemented());
  }

  /**
   * Responsible of fetching a **single** object from the storage. This method **must** resolve with an object.
   *
   * @method getObject
   * @return {Promise}
   */
  getObject() {
    return Promise.reject(new Restypie.RestErrors.NotImplemented());
  }

  /**
   * Responsible of fetching a **several** objects from the storage. This method **must** resolve with an array.
   *
   * @method getObjects
   * @return {Promise}
   */
  getObjects() {
    return Promise.reject(new Restypie.RestErrors.NotImplemented());
  }

  /**
   * Responsible of updating a **single** object in the storage.
   *
   * @method updateObject
   * @return {Promise}
   */
  updateObject() {
    return Promise.reject(new Restypie.RestErrors.NotImplemented());
  }

  /**
   * Responsible of deleting a **single** object from the storage.
   *
   * @method deleteObject
   * @return {Promise}
   */
  deleteObject() {
    return Promise.reject(new Restypie.RestErrors.NotImplemented());
  }

  /**
   * Responsible of replacing a **single** object in the storage.
   *
   * @method replaceObject
   * @return {Promise}
   */
  replaceObject() {
    return Promise.reject(new Restypie.RestErrors.NotImplemented());
  }

  /**
   * Builds a comprehensive object to describe the resource&#x27;s capabilities and schema.
   *
   * @method getSchemaDescription
   * @return {Object}
   */
  getSchemaDescription() {
    let description = {
      fields: {}
    };

    let self = this;
    let api = this.api;

    description.routes = this.routes.map(function (route) {
      return {
        method: route.method,
        path: Restypie.Url.join(&#x27;/&#x27;, api.path, self.path, route.path)
      };
    });

    this.fields.forEach(function (field) {
      let fieldDesc = description.fields[field.key] = {
        type: field.displayType,
        isRequired: field.isRequired,
        isReadable: field.isReadable,
        isFilterable: field.isFilterable,
        isWritable: field.isWritable,
        isUpdatable: field.isUpdatable,
        isPopulable: !!field.isPopulable,
        options: _.transform(_.pick(field, field.optionsProperties || []), function (obj, value, key) {
          obj[key] = value.toString();
        })
      };

      if (field.isFilterable) {
        fieldDesc.supportedOperators = field.supportedOperators.map(function (operator) {
          return operator.stringName;
        });
      }

    });

    return description;
  }

  /**
   * Looks into &#x60;resource.serializers&#x60; to find a serializer that corresponds to &#x60;type&#x60;. If none is found, &#x60;null&#x60; is
   * returned.
   *
   * @param {String} type
   * @return {Restypie.Serializers.AbstractSerializer | null}
   */
  getSerializerByAliasOrMimeType(type) {
    for (let serializer of this.serializers) {
      if (serializer.mimeType === type || _.includes(serializer.aliases, type)) return serializer;
    }
    return null;
  }

  /**
   * Decide which strategy to adopt to parse the body and fulfills &#x60;bundle.body&#x60;. Will reject with a 415 if the
   * content type cannot be negotiated.
   *
   * For now supports :
   * - &quot;multipart/form-data&quot; : for file uploads and fields
   * - &quot;application/json&quot; : &#x60;req.body&#x60; is assumed to be filled, not additional parsing is made
   *
   * @method parseBody
   * @param {Restypie.Bundle} bundle
   * @return {Promise}
   */
  parseBody(bundle) {
    // TODO Allow to define parsers just like serializers
    let supported = [&#x27;application/json&#x27;, &#x27;multipart/form-data&#x27;];
    switch (typeIs(bundle.req, supported)) {
      case &#x27;application/json&#x27;:
        return bundle.setBody(_.cloneDeep(bundle.req.body)).next();
      case &#x27;multipart/form-data&#x27;:
        return this._parseMultipart(bundle);
    }

    let headers = bundle.req.headers[&#x27;content-type&#x27;];
    return Promise.reject(new Restypie.TemplateErrors.UnsupportedFormat({ expected: supported, value: headers }));
  }

  /**
   * Sets &#x60;bundle.limit&#x60; either from the query string or using &#x60;resource.defaultLimit&#x60;.
   *
   * **Throws:**
   *
   * - &#x60;Restypie.TemplateErrors.BadType&#x60;: If &#x60;limit&#x60; has been provided in the query string but could not be casted
   * to a valid integer
   * - &#x60;Restypie.TemplateErrors.OutOfRange&#x60;: If the requested limit exceeds &#x60;resource.maxLimit&#x60; or is lower than 1
   *
   * @method parseLimit
   * @param {Restypie.Bundle} bundle
   */
  parseLimit(bundle) {
    let raw = bundle.query;

    if (raw.hasOwnProperty(&#x27;limit&#x27;)) {
      let rawLimit = raw.limit;
      let max = this.maxLimit;
      let parsedLimit = parseInt(rawLimit, 10);
      if (!Utils.isValidNumber(parsedLimit)) {
        throw new Restypie.TemplateErrors.BadType({ key: &#x27;limit&#x27;, value: rawLimit, expected: &#x27;integer&#x27; });
      }
      if (parsedLimit &lt; 0 || parsedLimit &gt; max) {
        throw new Restypie.TemplateErrors.OutOfRange({ key: &#x27;limit&#x27;, value: parsedLimit, min: 1, max });
      }
      bundle.setLimit(parsedLimit);
    } else {
      bundle.setLimit(this.defaultLimit);
    }
  }

  /**
   * Sets &#x60;bundle.offset&#x60; from the query string. Defaults to 0.
   *
   * **Throws:**
   *
   * - &#x60;Restypie.TemplateErrors.BadType&#x60;: If &#x60;offset&#x60; has been provided in the query string but could not be casted
   * to a valid integer
   * - &#x60;Restypie.TemplateErrors.OutOfRange&#x60;: If the requested offset is lower than 0
   *
   * @method parseOffset
   * @param {Restypie.Bundle} bundle
   */
  parseOffset(bundle) {
    let raw = bundle.query;

    if (raw.hasOwnProperty(&#x27;offset&#x27;)) {
      let rawOffset = raw.offset;
      let parsedOffset = parseInt(rawOffset, 10);
      if (!Utils.isValidNumber(parsedOffset)) {
        throw new Restypie.TemplateErrors.BadType({ key: &#x27;offset&#x27;, value: rawOffset, expected: &#x27;integer&#x27; });
      }
      if (parsedOffset &lt; 0) {
        throw new Restypie.TemplateErrors.OutOfRange({ key: &#x27;offset&#x27;, value: parsedOffset, min: 0 });
      }
      bundle.setOffset(parsedOffset);
    } else {
      bundle.setOffset(0);
    }
  }

  /**
   * Parses fields to be sorted. Defaults to &#x60;defaultSort&#x60;.
   *
   * @method parseSort
   * @param {Restypie.Bundle} bundle
   */
  parseSort(bundle) {
    let fieldsByKey = this.fieldsByKey;
    let sort = this.constructor.listToArray(bundle.query.sort);
    sort.forEach(function (key) {
      key = key.replace(/^-/, &#x27;&#x27;);
      let field = fieldsByKey[key];
      if (!field || !field.isFilterable) throw new Restypie.TemplateErrors.UnknownPath({ key });
    });
    if (!sort.length) sort = this.defaultSort;

    bundle.setSort(sort.map(function (key) {
      let isNegative = false;
      if (/^-/.test(key)) {
        isNegative = true;
        key = key.replace(/^-/, &#x27;&#x27;);
      }
      return (isNegative ? &#x27;-&#x27; : &#x27;&#x27;) + fieldsByKey[key].path;
    }));
  }

  /**
   * Sets &#x60;bundle.format&#x60; either from the query string of the &#x60;Accept&#x60; header, the query string having the precedence.
   *
   * **Throws:**
   * - &#x60;Restypie.TemplateErrors.UnsupportedFormat&#x60;: If no corresponding serializer is found.
   *
   * @param {Restypie.Bundle} bundle
   */
  parseFormat(bundle) {
    let raw = bundle.query;
    let desired;
    let format;

    if (raw.hasOwnProperty(&#x27;format&#x27;)) {
      desired = raw.format;
      let serializer = this.getSerializerByAliasOrMimeType(raw.format);
      if (serializer) format = serializer.mimeType;
    } else {
      desired = bundle.req.headers.accept;
      format = new Negotiator(bundle.req).mediaType(this.supportedFormatMimeTypes);
    }

    if (!format) {
      let meta = { expected: this.supportedFormatMimeTypesAndAliases, value: desired };
      throw new Restypie.TemplateErrors.UnsupportedFormat(meta);
    }

    bundle.setFormat(format);
  }

  /**
   * Parses the filters.
   *
   * @method parseFilters
   * @param {Restypie.Bundle} bundle
   */
  parseFilters(bundle) {
    // TODO parse foreign keys

    let fieldsMap = this.fieldsByKey;
    let query = _.omit(bundle.query, RESERVED_KEYWORDS);
    let filters = {};
    let separator = this.constructor.OPERATOR_SEPARATOR;
    let equalityOperator = this.constructor.EQUALITY_OPERATOR;

    this.beforeParseFilters(bundle);

    for (let prop in query) {

      let couple = prop.split(separator);
      if (couple.length &gt; 2) {
        throw new Restypie.TemplateErrors.UnknownPath({ key: couple.slice(0, couple.length - 1).join(separator) });
      }
      if (couple.length === 1) couple.push(equalityOperator);

      let key = couple[0];
      let operator = couple[1];
      let value = query[prop];

      let field = fieldsMap[key];
      if (field) {
        if (!field.isFilterable) throw new Restypie.TemplateErrors.NotFilterable({ key });

        let operatorClass = field.getOperatorByName(operator);
        if (!operatorClass) throw new Restypie.TemplateErrors.UnsupportedOperator({ key, operator });

        filters[field.path] = filters[field.path] || {};

        value = operatorClass.parse(value);
        filters[field.path][operator] = Array.isArray(value) ?
          value.map(field.hydrate.bind(field)) :
          field.hydrate(value);
      } else {
        throw new Restypie.TemplateErrors.UnknownPath({ key });
      }
    }

    for (let key in filters) {
      let filter = filters[key];
      if (filter.hasOwnProperty(equalityOperator) &amp;&amp; Object.keys(filter).length &gt; 1) {
        throw new Restypie.TemplateErrors.NotMixableOperators({ key, operators: Object.keys(filter).slice(0, 2) });
      }
    }

    bundle.setFilters(filters);

    this.afterParseFilters(bundle);
  }

  /**
   * Parses fields to be selected. Returns &#x60;defaultSelect&#x60; if none.
   *
   * @method parseSelect
   * @param {Restypie.Bundle} bundle
   */
  parseSelect(bundle) {
    let fieldsByKey = this.fieldsByKey;
    let select = this.constructor.listToArray(bundle.query.select);
    select.forEach(function (key) {
      let field = fieldsByKey[key];
      if (!field || !field.isReadable) throw new Restypie.TemplateErrors.UnknownPath({ key });
    });
    if (!select.length) select = this.defaultSelect;

    bundle.setSelect(select.map(function (selected) {
      return fieldsByKey[selected].path;
    }));
  }

  /**
   * Parses fields to populate.
   *
   * @method parsePopulate
   * @param {Restypie.Bundle} bundle
   */
  parsePopulate(bundle) {
    let fieldsByKey = this.fieldsByKey;
    let toPopulate = this.constructor.listToArray(bundle.query.populate).reduce(function (acc, key) {
      let parts = key.split(&#x27;.&#x27;);
      let rootKey = parts.shift();
      let field = fieldsByKey[rootKey];
      if (!field) throw new Restypie.TemplateErrors.UnknownPath({ key: rootKey });
      if (!field.isPopulable) throw new Restypie.TemplateErrors.NotPopulable({ key: rootKey });
      let obj = acc.find((item) =&gt; item.key === rootKey);
      if (!obj) {
        obj = { key: rootKey, populate: [] };
        acc.push(obj);
      }
      if (parts.length) obj.populate.push(parts.join(&#x27;.&#x27;));
      return acc;
    }, []);
    bundle.setPopulate(toPopulate);
  }

  /**
   *
   * @param {Restypie.Bundle} bundle
   */
  parseOptions(bundle) {
    try {
      this.parseLimit(bundle);
      this.parseSelect(bundle);
      this.parseOffset(bundle);
      this.parseFormat(bundle);
      this.parseFilters(bundle);
      this.parsePopulate(bundle);
      this.parseSort(bundle);
    } catch (err) {
      return Promise.reject(err);
    }
    return bundle.next();
  }

  /**
   * Transforms each keys and values into their internal version.
   *
   * @method hydrate
   * @async
   * @param {Restypie.Bundle} bundle
   * @return {Promise}
   *
   * @example
   * Given the following &#x60;users&#x60; resource definition :
   * &#x60;&#x60;&#x60;javascript
   * let usersResource = new Restypie.Resources.FixturesResource({
   *   path: &#x27;/users&#x27;,
   *   writableFields: [&#x27;firstName&#x27;, &#x27;lastName&#x27;, &#x27;yearOfBirth&#x27;, &#x27;profilePicture&#x27;]
   *   schema: {
   *     firstName: { path: &#x27;fName&#x27;, type: String },
   *     lastName: { path: &#x27;lName&#x27;, type: String },
   *     yearOfBirth: { path: &#x27;year&#x27;, type: &#x27;int&#x27; },
   *     profilePicture: { path: &#x27;pic&#x27;, type: &#x27;file&#x27; }
   *   }
   * });
   * &#x60;&#x60;&#x60;
   * And the following multipart request against the API :
   * &#x60;&#x60;&#x60;javascript
   * // POST /my-api/users
   * // Content-Type: multipart/form-data
   * // Body :
   * {
   *   firstName: &#x27;John&#x27;,
   *   lastName: &#x27;Doe&#x27;,
   *   yearOfBirth: &#x27;1986&#x27;,
   *   profilePicture: ** a file named foo.png **
   * }
   * &#x60;&#x60;&#x60;
   * **Before** being _hydrated_ (aka, went through the &#x60;hydrate&#x60; method), &#x60;bundle.body&#x60; will look like :
   * &#x60;&#x60;&#x60;javascript
   * bundle.body = {
   *   firstName: &#x27;John&#x27;,
   *   lastName: &#x27;Doe&#x27;,
   *   yearOfBirth: &#x27;1986&#x27;,
   *   profilePicture: &#x27;path/to/tmp/dir/restypie_1449991977517_foo.png&#x27; // The file has been automatically written
   * };
   * &#x60;&#x60;&#x60;
   * **After** having been _hydrated_, &#x60;bundle.body&#x60; will look like :
   * &#x60;&#x60;&#x60;javascript
   * bundle.body = { // Fields now have their internal name (&quot;path&quot;)
   *   fName: &#x27;John&#x27;,
   *   lName: &#x27;Doe&#x27;,
   *   year: 1986, // Casted into an integer
   *   pic: &#x27;path/to/tmp/dir/restypie_1449991977517_foo.png&#x27;
   * };
   * &#x60;&#x60;&#x60;
   */
  hydrate(bundle) {
    let data = bundle.body;

    if (!_.isObject(data)) return bundle.next();

    let fieldsMap = this.fieldsByKey;
    let keys = Object.keys(fieldsMap);
    let isArray = Array.isArray(data);
    if (!isArray) data = [data];

    let final = [];

    return this.beforeHydrate(bundle)
      .then(function () {
        for (let object of data) {

          // Reject attempts to write fields that are not known
          let unknownKeys = Object.keys(_.omit(object, keys));
          if (unknownKeys.length) return bundle.next(new Restypie.TemplateErrors.UnknownPath({ key: unknownKeys[0] }));

          let ret = {};

          // Now the object is assumed to contain only known keys
          for (let key of keys) {
            let field = fieldsMap[key];
            if (object.hasOwnProperty(key) || (!bundle.isUpdate &amp;&amp; field.hasDefault)) {
              try {
                ret[field.path] = field.hydrate(object[key]);
              } catch (err) {
                return bundle.next(err);
              }
            }
          }

          final.push(ret);
        }

        return bundle.setBody(isArray ? final : final[0]).next();
      }).then(this.afterHydrate.bind(this, bundle))
        .then(function () { return bundle.next(); });
  }

  /**
   *
   *
   * @method validate
   * @async
   * @param {Restypie.Bundle} bundle
   */
  validate(bundle) {
    let data = bundle.body;

    if (!_.isObject(data)) return bundle.next();

    let fieldsMap = this.fieldsByPath;
    let isUpdate = bundle.isUpdate;
    let isArray = Array.isArray(data);
    if (!isArray) data = [data];

    return this.beforeValidate(bundle)
      .then(function () {
        for (let object of data) {
          for (let key of Object.getOwnPropertyNames(fieldsMap)) {
            let field = fieldsMap[key];
            let value = object[key];
            try {
              if (!isUpdate) field.validatePresence(value);
            } catch (err) {
              return bundle.next(err);
            }
            if (field.isPresent(value)) {
              if (!field.isWritable) {
                return bundle.next(new Restypie.TemplateErrors.NotWritable({ key: field.key, value }));
              }
              if (isUpdate &amp;&amp; !field.isUpdatable) {
                return bundle.next(new Restypie.TemplateErrors.NotUpdatable({ key: field.key, value }));
              }
              field.validate(value);
            }
          }
        }

        return bundle.next();
      }).then(this.afterValidate.bind(this, bundle))
        .then(function () { return bundle.next(); });
  }

  /**
   * Formats &#x60;bundle.data&#x60; before it is delivered. For security reasons, only fields that are &#x60;isSelectable&#x60; are
   * returned.
   *
   * @methods dehydrate
   * @async
   * @param {Restypie.Bundle} bundle
   * @return {Promise}
   */
  dehydrate(bundle) {
    let data = bundle.data;

    if (!_.isObject(data)) return bundle.next();

    let isArray = Array.isArray(data);
    let fields = this.readableFields;
    if (!isArray) data = [data];

    data = data.map(function (object) {
      let ret = {};
      fields.forEach(function (field) {
        if (object.hasOwnProperty(field.path)) {
          let value = object[field.path];
          ret[field.key] = field.isPresent(value) ? field.dehydrate(value) : value;
        }
      });
      return ret;
    });

    return bundle.setData(isArray ? data : data[0]).next();
  }

  /**
   * Populates properties of the objects in &#x60;bundle.data&#x60; by requesting the associated resources.
   *
   * @method populate
   * @param {Restypie.Bundle} bundle
   * @return {Promise}
   *
   * FIXME this function is way too complex !
   */
  populate(bundle) {
    if (!bundle.populate) {
      try {
        this.parsePopulate(bundle);
      } catch (ex) {
        return Promise.reject(ex);
      }
    }

    if (!bundle.populate.length) return bundle.next(); // Nothing to do

    let self = this;
    let fieldsByKey = this.fieldsByKey;

    return Promise.all(bundle.populate.map(function (keyDef) {
      let key = keyDef.key;

      let field = fieldsByKey[key];
      if (!field || !field.isReadable) return bundle.next(new Restypie.TemplateErrors.UnknownPath({ key }));
      if (!field.isPopulable) return bundle.next(new Restypie.TemplateErrors.NotPopulable({ key }));

      let resource = field.to;
      Restypie.Utils.isInstanceOf(resource, Restypie.Resources.AbstractCoreResource, true);

      let data = Array.isArray(bundle.data) ? bundle.data : [bundle.data];

      return Promise.all(data.map(function (object) {
        if (Restypie.Utils.isNone(object[key]) &amp;&amp; !field.isRelation) return Promise.resolve();

        let toKeyField = resource.fieldsByKey[field.toKey];
        Restypie.Utils.isInstanceOf(toKeyField, Restypie.Fields.AbstractField, true);

        let url;
        let qs = {};
        if (keyDef.populate.length) qs.populate = keyDef.populate.join(&#x27;,&#x27;);
        let headers = _.omit(bundle.req.headers, [&#x27;Content-Type&#x27;, &#x27;Accept&#x27;]); // Copy custom headers (ie, auth)
        let tasks = [];

        if (field.isManyRelation) {
          url = Restypie.Url.join(resource.getFullUrl());
          qs.limit = 0;

          let through = field.through;

          if (through) {
            Restypie.Utils.isInstanceOf(through, Restypie.Resources.AbstractCoreResource, true);

            let throughKeyField = through.fieldsByKey[field.throughKey];
            let otherThroughKeyField = field.through.fieldsByKey[field.otherThroughKey];
            Restypie.Utils.isInstanceOf(throughKeyField, Restypie.Fields.AbstractField, true);
            Restypie.Utils.isInstanceOf(otherThroughKeyField, Restypie.Fields.AbstractField, true);

            tasks.push(function () {
              return new Promise(function (resolve, reject) {
                return request({
                  method: &#x27;GET&#x27;,
                  url: through.getFullUrl(),
                  qs: {
                    [throughKeyField.key]: object[self.primaryKeyField.key],
                    limit: 0, // All items
                    select: otherThroughKeyField.key // Only what we need
                  },
                  json: true,
                  headers: headers
                }, function (err, res, body) {
                  if (err || res.statusCode !== Restypie.Codes.OK) {
                    return reject(err || Restypie.RestErrors.fromStatusCode(res.statusCode, res.body.message));
                  }
                  let list = _.uniq(_.map(body.data, otherThroughKeyField.key));
                  if (list.length) {
                    qs[toKeyField.key + &#x27;__in&#x27;] = list.join(&#x27;,&#x27;);
                    return resolve();
                  } else {
                    object[key] = []; // Empty array since there are no results
                    return resolve(true); // Do not continue
                  }
                });
              });
            });
          } else {
            qs[toKeyField.key] = object[self.primaryKeyField.key];
          }
        } else {
          url = Restypie.Url.join(resource.getFullUrl(), object[key]);
        }


        tasks.push(function (shouldStop) {
          return new Promise(function (resolve, reject) {
            if (shouldStop) return resolve();

            return request({
              method: &#x27;GET&#x27;,
              url,
              qs,
              headers,
              json: true
            }, function (err, res, body) {
              if (err || res.statusCode !== Restypie.Codes.OK) {
                return reject(err || Restypie.RestErrors.fromStatusCode(res.statusCode, res.body.message));
              }
              if (!field.isManyRelation &amp;&amp; Array.isArray(body.data)) {
                return reject(new Error(&#x27;Unfiltered ToOne relation, consider using ToManyField : &#x27; + field.key));
              }
              object[key] = body.data;
              return resolve();
            });
          });
        });

        return tasks.reduce(function (acc, task) {
          return acc.then(task);
        }, Promise.resolve());

      }));

    })).then(function () { return bundle.next(); });
  }

  /**
   * Serializes &#x60;bundle.payload&#x60; according to &#x60;bundle.format&#x60;, assuming that the format is valid and has been parsed
   * by &#x60;resource.parseFormat&#x60;.
   *
   * @method serialize
   * @param {Restypie.Bundle} bundle
   * @return {Promise}
   */
  serialize(bundle) {
    if (!bundle.format) {
      try {
        this.parseFormat(bundle);
      } catch (err) {
        return bundle.next(err);
      }
    }

    return this.getSerializerByAliasOrMimeType(bundle.format)
      .serialize(bundle.payload)
      .then(function (content) {
        return bundle.assignToHeaders({ &#x27;Content-Type&#x27;: bundle.format }).setPayload(content).next();
      })
      .catch (function (err) {
        return bundle.setError(err).next();
      });
  }

  /**
   * Sends the final response.
   *
   * - Extracts the status code from &#x60;bundle.statusCode&#x60;
   * - Extracts the headers code from &#x60;bundle.headers&#x60;
   * - Extracts the response body code from &#x60;bundle.payload&#x60;
   *
   * @method respond
   * @param {Restypie.Bundle} bundle
   */
  respond(bundle) {
    let res = bundle.res;
    let statusCode = bundle.statusCode;

    // Headers
    for (let header of Object.getOwnPropertyNames(bundle.headers)) {
      res.setHeader(header, bundle.headers[header]);
    }

    // Status code
    if (statusCode) res.status(statusCode);

    // Log request errors
    switch (true) {
      case !statusCode:
        Restypie.Logger.error(&#x27;No statusCode for request on &#x27; + bundle.req.originalUrl);
        break;
      case statusCode === Restypie.Codes.InternalServerError:
        Restypie.Logger.error(bundle.err.stack, bundle.err);
        break;
      case statusCode &gt; Restypie.Codes.BadRequest:
        Restypie.Logger.warn(bundle.err.stack, bundle.err);
        break;
    }

    return res.send(bundle.payload || &#x27;&#x27;);
  }


  /**
   * Parses files and fields from a multipart request. The files field names must match an existing &#x60;FileField&#x60; in the
   * schema. If no match is found, the file is not written and the method rejects. If a file size exceeds the &#x60;maxSize&#x60;
   * defined in the field, the request is rejected and the started upload rolled back in the storage.
   *
   * @method _parseMultipart
   * @param {Restypie.Bundle} bundle
   * @return {Promise}
   * @private
   */
  _parseMultipart(bundle) {
    // TODO move this part into a dedicated parser file
    let fields = this.fields;
    let fileFields = this.fileFields;

    return new Promise(function (resolve, reject) {
      let files = {};
      let body = {};
      let parser = new Busboy({ headers: bundle.req.headers });

      // Stop the request and reject if any error
      function onError(err) {
        bundle.req.pause();
        // Block Busboy from retrieving more data
        parser._parser.parser.removeAllListeners(&#x27;part&#x27;);
        return reject(err);
      }

      parser.on(&#x27;field&#x27;, function (name, value) { body[name] = value; });

      /* jshint -W072 */
      parser.on(&#x27;file&#x27;, function (name, file, fileName, encoding, mimeType) {
        /* jshint +W072 */

        // Retrieve the corresponding field
        let fileField = fileFields.find(function (field) { return field.key === name; });

        // Base definition for the file, missing &#x60;path&#x60; for now
        let fileDesc = { name: fileName, mimeType, encoding, size: 0 };

        // Per file error handler
        function onWriteError(err) {
          // Do not receive more data
          file.removeAllListeners(&#x27;data&#x27;);
          // Remove the partially uploaded file if written - silently
          if (fileField) fileField.unlink(fileDesc).catch (function () { /* TODO handle error */ });
          // Reject
          return onError(err);
        }

        // Do not write the file if it&#x27;s not a file field
        if (!fileField) {
          let field = fields.find(function (field) { return field.key === name; });
          if (field) {
            let meta = { key: field.key, type: &#x27;file&#x27;, expected: field.displayType };
            return onWriteError(new Restypie.TemplateErrors.BadType(meta));
          } else {
            return onWriteError(new Restypie.TemplateErrors.UnknownPath({ key: name }));
          }
        }


        // Shortcut for size validation
        function validateSize() {
          try {
            fileField.validateSize(fileDesc);
          } catch (err) {
            return onWriteError(err);
          }
        }

        // Create the write stream
        let writeStream = fileField.writeStream(fileDesc);

        // Catch errors on the file
        file.on(&#x27;error&#x27;, onWriteError);

        // Measure and validate file size
        file.on(&#x27;data&#x27;, function (data) {
          fileDesc.size += data.length;
          validateSize();
        });

        // Catch errors on the write stream
        writeStream.on(&#x27;error&#x27;, onWriteError);

        // Register the file once it&#x27;s fully uploaded. First validate that it has a &#x60;path&#x60;.
        file.on(&#x27;end&#x27;, function () {
          if (!_.isString(fileDesc.path)) return onError(new Error(&#x27;&#x60;file.path&#x60; must be fulfilled during streaming&#x27;));
          files[name] = fileDesc.path;
        });

        // Finally open the stream
        return file.pipe(writeStream);
      });

      parser.on(&#x27;error&#x27;, onError);

      parser.on(&#x27;finish&#x27;, function () {
        body = formDataToObject.toObj(body);
        Object.assign(body, files);
        bundle.setBody(body);
        return resolve(bundle);
      });

      return bundle.req.pipe(parser);
    });
  }

  static get LIST_SEPARATOR() { return /\s*,\s*/; }

  static get OPERATOR_SEPARATOR() { return &#x27;__&#x27;; }

  static get EQUALITY_OPERATOR() { return &#x27;eq&#x27;; }

  static listToArray(str) {
    if (!str) return [];
    return str.split(this.LIST_SEPARATOR);
  }

};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
